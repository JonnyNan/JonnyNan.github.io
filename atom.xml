<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jonny&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/8cf42671f56c0b7224109b4dabcec88b</icon>
  <subtitle>致良知</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="//jonnynan.github.io/"/>
  <updated>2021-06-24T08:19:40.525Z</updated>
  <id>//jonnynan.github.io/</id>
  
  <author>
    <name>南璋</name>
    <email>nanzhang1211@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git系列之远程仓库</title>
    <link href="//jonnynan.github.io/2019/08/19/git%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>//jonnynan.github.io/2019/08/19/git系列之远程仓库/</id>
    <published>2019-08-19T09:11:54.000Z</published>
    <updated>2021-06-24T08:19:40.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="使用github"><a href="#使用github" class="headerlink" title="使用github"></a>使用github</h2><p>远程仓库有很多，最常用的就是国际上的github。国内也有码云，码市。<br>当然有些公司也会自己搭建git服务器，开源的比如gitlab。但是为了学习远程仓库去自己搭建服务器就有点小题大做了。</p><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>只要注册一个GitHub账号，就可以免费获得Git远程仓库</p><h3 id="创建SSH-key"><a href="#创建SSH-key" class="headerlink" title="创建SSH key"></a>创建SSH key</h3><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置.</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:youremail@example.com" target="_blank" rel="noopener">youremail@example.com</a>“</p></blockquote><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，无需创建密码。</p><p>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><p>第2步，登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，比如『我的macbookpro』在Key文本框里粘贴id_rsa.pub文件的内容.</p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>github免费版的仓库默认是公开的，所有人都能看到，所以敏感信息不要放到里面。也可以付费获取隐私空间。当然企业开发大多数都是自己搭建私有的gitlab。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作.</p><p>登录github后，右上角找到“Create a new repo”按钮，创建一个新的仓库.</p><p>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p><p>目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><h3 id="关联本地库"><a href="#关联本地库" class="headerlink" title="关联本地库"></a>关联本地库</h3><blockquote><p>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:jonnynan/learngit.git</p></blockquote><p>请千万注意，把上面的jonnynan替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push -<span class="keyword">u</span> origin master</span><br><span class="line">Counting object<span class="variable">s:</span> <span class="number">20</span>, done.</span><br><span class="line">Delta compression using <span class="keyword">up</span> <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line">Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), done.</span><br><span class="line">Writing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">20</span>/<span class="number">20</span>), <span class="number">1.64</span> KiB | <span class="number">560.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">20</span> (delta <span class="number">5</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: Resolving delta<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">To github.<span class="keyword">com</span>:jonnynan/learngit.git</span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">'master'</span> <span class="keyword">set</span> <span class="keyword">up</span> <span class="keyword">to</span> track remote branch <span class="string">'master'</span> from <span class="string">'origin'</span>.</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。</p><p>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h3 id="ssh-警告"><a href="#ssh-警告" class="headerlink" title="ssh 警告"></a>ssh 警告</h3><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'github.com (xx.xx.xx.xx)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'github.com'</span> (RSA) <span class="built_in">to</span> <span class="keyword">the</span> list <span class="keyword">of</span> known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h3 id="远程库克隆"><a href="#远程库克隆" class="headerlink" title="远程库克隆"></a>远程库克隆</h3><p>上面讲了先有本地库，后有远程库的时候，如何关联远程库。</p><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><p>首先，登陆GitHub，创建一个新的仓库，名字叫gitskills：</p><p>我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件：</p><p>现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git<span class="meta">@github</span>.<span class="string">com:</span>jonnynan/gitskills.git</span><br><span class="line">Cloning into <span class="string">'gitskills'</span>...</span><br><span class="line"><span class="string">remote:</span> Counting <span class="string">objects:</span> <span class="number">3</span>, done.</span><br><span class="line"><span class="string">remote:</span> Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">3</span></span><br><span class="line">Receiving <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br></pre></td></tr></table></figure><p>注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了：</p><blockquote><p>$ cd gitskills</p></blockquote><blockquote><p>$ ls</p></blockquote><blockquote><p>README.md</p></blockquote><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用这样的地址。</p><blockquote><p><a href="https://github.com/jonnynan/gitskills.git" target="_blank" rel="noopener">https://github.com/jonnynan/gitskills.git</a> </p></blockquote><p>实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。</p><p>使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。</p><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h1&gt;&lt;h2 id=&quot;使用github&quot;&gt;&lt;a href=&quot;#使用github&quot; class=&quot;headerlink&quot; title=&quot;使
      
    
    </summary>
    
    
      <category term="git" scheme="//jonnynan.github.io/tags/git/"/>
    
      <category term="版本控制" scheme="//jonnynan.github.io/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用Logrotate归档日志</title>
    <link href="//jonnynan.github.io/2019/08/15/%E4%BD%BF%E7%94%A8Logrotate%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97/"/>
    <id>//jonnynan.github.io/2019/08/15/使用Logrotate归档日志/</id>
    <published>2019-08-15T08:59:43.000Z</published>
    <updated>2021-06-24T08:19:40.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于日志切割"><a href="#关于日志切割" class="headerlink" title="关于日志切割"></a>关于日志切割</h1><p>日志文件包含了关于系统中发生的事件的有用信息，在排障过程中或者系统性能分析时经常被用到。对于忙碌的服务器，日志文件大小会增长极快，服务器会很快消耗磁盘空间，这成了个问题。除此之外，处理一个单个的庞大日志文件也常常是件十分棘手的事。<br>　　logrotate是个十分有用的工具，它可以自动对日志进行截断（或轮循）、压缩以及删除旧的日志文件。例如，你可以设置logrotate，让/var/log/foo日志文件每30天轮循，并删除超过6个月的日志。配置完后，logrotate的运作完全自动化，不必进行任何进一步的人为干预。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>以 centos 为例：</p><blockquote><p>$ yum -y install logrotate</p></blockquote><p>安装后应该存在三个文件夹:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/etc/</span>cron.daily/logrotate</span><br><span class="line"><span class="meta-keyword">/etc/</span>logrotate.conf <span class="meta"># 主配置文件</span></span><br><span class="line"><span class="meta-keyword">/etc/</span>logrotate.d <span class="meta"># 配置目录</span></span><br></pre></td></tr></table></figure><p>logrotate的配置文件是/etc/logrotate.conf，通常不需要对它进行修改。日志文件的轮循设置在独立的配置文件中，它（们）放在/etc/logrotate.d/目录下。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>假设我们要分割的是tomcat的日志catalina.out</p><h2 id="创建tomcat的配置文件"><a href="#创建tomcat的配置文件" class="headerlink" title="创建tomcat的配置文件"></a>创建tomcat的配置文件</h2><blockquote><p>vim /etc/logrotate.d/tomcat</p></blockquote><p>内容：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/application/tomcat/logs/catalina.<span class="keyword">out</span> &#123;</span><br><span class="line"><span class="built_in">daily</span></span><br><span class="line">copytruncate</span><br><span class="line"><span class="keyword">rotate</span> 30</span><br><span class="line"><span class="keyword">compress</span></span><br><span class="line">notifempty</span><br><span class="line">dateext</span><br><span class="line">missingok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面内容中大括号前面内容为 待处理日志文件的绝对路径。<br>大括号里面的都是Logrotate工具的参数</p><p>关于每个参数的作用我们可以查看全局文件cat /etc/logrotate.conf 我们可以把配置文件写在/etc/logrotate.conf里面或者放在/etc/logrotate.d下面</p><h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">daily 表示每天整理一次</span><br><span class="line">rotate <span class="number">20</span> 表示保留<span class="number">20</span>天的备份文件</span><br><span class="line">dateext 文件后缀是日期格式,也就是切割后文件是:xxx<span class="selector-class">.log-20171205</span><span class="selector-class">.gz</span></span><br><span class="line">copytruncate 用于还在打开中的日志文件，把当前日志备份并截断</span><br><span class="line">compress 通过gzip压缩转储以后的日志（gzip -d xxx.gz解压）</span><br><span class="line">missingok 如果日志不存在则忽略该警告信息</span><br><span class="line">notifempty 如果是空文件的话，不转储</span><br><span class="line"><span class="selector-id">#size</span> <span class="number">5</span>M #当catalina.out大于<span class="number">5</span>M就进行切割，可用可不用！</span><br></pre></td></tr></table></figure><h2 id="不常用的参数"><a href="#不常用的参数" class="headerlink" title="不常用的参数"></a>不常用的参数</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">weekly 指定转储周期为每周</span><br><span class="line">monthly 指定转储周期为每月</span><br><span class="line">nocompress 不需要压缩时，用这个参数</span><br><span class="line">nocopytruncate 备份日志文件但是不截断</span><br><span class="line">create mode owner<span class="built_in"> group </span>转储文件，使用指定的文件模式创建新的日志文件</span><br><span class="line">nocreate 不建立新的日志文件</span><br><span class="line">delaycompress 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩</span><br><span class="line">nodelaycompress 覆盖 delaycompress 选项，转储同时压缩</span><br><span class="line">errors<span class="built_in"> address </span>转储时的错误信息发送到指定的Email 地址</span><br><span class="line">ifempty 即使是空文件也转储，这个是 logrotate 的缺省选项。</span><br><span class="line">mail<span class="built_in"> address </span>把转储的日志文件发送到指定的E-mail 地址</span><br><span class="line">nomail 转储时不发送日志文件</span><br><span class="line">olddir directory 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统</span><br><span class="line">noolddir 转储后的日志文件和当前日志文件放在同一个目录</span><br><span class="line">prerotate/endscript 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行</span><br><span class="line">postrotate/endscript 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行</span><br></pre></td></tr></table></figure><p>温馨提示：配置文件里一定要配置rotate 文件数目这个参数。如果不配置默认是0个，也就是只允许存在一份日志，刚切分出来的日志会马上被删除</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol><li>调试 （d = debug）参数为配置文件，不指定则执行全局配置文件</li></ol><blockquote><p>logrotate -d /etc/logrotate.d/tomcat.conf</p></blockquote><ol start="2"><li>强制执行（-f = force），可以配合-v(-v =verbose）使用，注意调试信息默认携带-v；</li></ol><blockquote><p>logrotate -v -f /etc/logrotate.d/tomcat.conf</p></blockquote><p>配合crontab定时器即可实现每天备份当天日志并压缩归档了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于日志切割&quot;&gt;&lt;a href=&quot;#关于日志切割&quot; class=&quot;headerlink&quot; title=&quot;关于日志切割&quot;&gt;&lt;/a&gt;关于日志切割&lt;/h1&gt;&lt;p&gt;日志文件包含了关于系统中发生的事件的有用信息，在排障过程中或者系统性能分析时经常被用到。对于忙碌的服务器，日
      
    
    </summary>
    
    
      <category term="日志" scheme="//jonnynan.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
      <category term="运维" scheme="//jonnynan.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>git系列之时光穿梭</title>
    <link href="//jonnynan.github.io/2019/08/13/git%E7%B3%BB%E5%88%97%E4%B9%8B%E6%97%B6%E5%85%89%E7%A9%BF%E6%A2%AD/"/>
    <id>//jonnynan.github.io/2019/08/13/git系列之时光穿梭/</id>
    <published>2019-08-13T08:25:47.000Z</published>
    <updated>2021-06-24T08:19:40.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时光穿梭"><a href="#时光穿梭" class="headerlink" title="时光穿梭"></a>时光穿梭</h1><p>上次内容我们已经生成了一个git仓库，并且创建了一个readme.txt文件。<br>通过 下面命令添加到git仓库</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> readme.txt </span></span><br><span class="line">$ git commit -m <span class="string">"add file"</span></span><br></pre></td></tr></table></figure><p>下面我们来编辑下readme.txt文件,比如改成：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software.</span><br></pre></td></tr></table></figure><p>通过 git status 命令来查询当前仓库状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git status</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>上面输出内容告诉我们，readme.txt 文件被修改过了，但是没有准备提交的修改。</p><p>通过  git diff 命令 查看修改内容</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line"><span class="comment">--- a/readme.txt</span></span><br><span class="line"><span class="comment">+++ b/readme.txt</span></span><br><span class="line"><span class="meta">@@ -1,2 +1,2 @@</span></span><br><span class="line"><span class="deletion">-Git is a version control system.</span></span><br><span class="line"><span class="addition">+Git is a distributed version control system.</span></span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p>git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。</p><p>知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> readme.txt</span></span><br></pre></td></tr></table></figure><p>再第二步 git commit -m 之前 我们先 看看当前状态</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add distributed"</span></span><br><span class="line">[<span class="keyword">master</span> e475afc] <span class="keyword">add</span> <span class="keyword">distributed</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><p>提交后，我们再用git status命令看看仓库的当前状态：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch <span class="literal">master</span></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>要随时掌握工作区的状态，使用git status命令。</p><p>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>git 每次 commit 都会产生一个 版本 commit 编号</p><p>查看可以使用  git log 命令</p><p>需要友情提示的是，你看到的一大串类似1094adb…的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb…（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><p>现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></span><br><span class="line"><span class="keyword">HEAD</span> <span class="keyword">is</span> <span class="keyword">now</span> <span class="keyword">at</span> e475afc <span class="keyword">add</span> <span class="keyword">distributed</span></span><br></pre></td></tr></table></figure><p>查看文件可以发现确实已经回到了上个版本提交的内容。</p><p>此时再次查看git log，会发现最新的版本不再显示了。就好像你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>还是有办法 。再学两个命令：</p><p>git reflog  查看之前执行的每个命令。找到对应的 commit log</p><p>然后执行命令 git reset –hard commit_id </p><p>即可恢复到指定提交版本了。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p><h1 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h1><p>核心知识点来了。</p><p>git学的好不好最要紧的就是理解这个暂存区。</p><h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><p>首先来看看什么是工作区。</p><p>我们在某个空文件夹内执行了 git init 命令。此文件夹以及其子文件夹就都属于工作区。</p><p>注意 目录中 有一个 .git的隐藏目录 ，它属于版本库,不算工作区。</p><h2 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h2><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD</p><p>分支和HEAD以后再讲。</p><p>前面说了往git仓库中加文件需要两步走，第一步add 第二步 commit,其实这里：<br>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>此时我们编辑下 redeme.txt文件，再新建一个 LICENSE 文件。</p><p>git status 查看状态 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">include</span> <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">LICENSE</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。</p><p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">file</span>:   LICENSE</span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></table></figure><p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"understand how stage works"</span></span><br><span class="line">[<span class="keyword">master</span> e43a48b] understand how stage works</span><br><span class="line"> <span class="number">2</span> files <span class="keyword">changed</span>, <span class="number">2</span> insertions(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> LICENSE</span><br></pre></td></tr></table></figure><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch <span class="literal">master</span></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么</p><h1 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h1><p>git 管理的是修改本身，而不是文件。这也是git的特色之一。</p><p>假如你修改了一次 readme.txt add了 一次 。然后又修改了一次 readme.txt，再提交。</p><p>此时 执行 git status,你会发现第二次的修改没有被提交。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git <span class="keyword">commit</span>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</span><br><span class="line"></span><br><span class="line">提交后，用git diff <span class="keyword">HEAD</span> <span class="comment">-- readme.txt命令可以查看工作区和版本库里面最新版本的区别：</span></span><br></pre></td></tr></table></figure><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit.<br>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme<span class="selector-class">.txt</span> </span><br><span class="line">diff --git a/readme<span class="selector-class">.txt</span> b/readme.txt</span><br><span class="line">index <span class="number">76</span>d770f.<span class="selector-class">.a9c5755</span> <span class="number">100644</span></span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -<span class="number">1</span>,<span class="number">4</span> +<span class="number">1</span>,<span class="number">4</span> @@</span><br><span class="line"> Git is <span class="selector-tag">a</span> distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has <span class="selector-tag">a</span> mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。</p><p>#撤销修改</p><p>万一我提交的东西里面有错误内容，可以后悔吗？可以！</p><h2 id="丢弃工作区修改"><a href="#丢弃工作区修改" class="headerlink" title="丢弃工作区修改"></a>丢弃工作区修改</h2><p>丢弃工作区的修改 ,恢复到上次提交时候的内容</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- readme.txt</span></span><br></pre></td></tr></table></figure><p>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h2 id="还原暂存区的修改"><a href="#还原暂存区的修改" class="headerlink" title="还原暂存区的修改"></a>还原暂存区的修改</h2><p>执行了 git add 还没有 commit 的修改也能撤销</p><p>Git同样告诉我们，用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> readme.txt</span><br><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span><br><span class="line">Mreadme.txt</span><br></pre></td></tr></table></figure><p>git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。</p><p>现在用git status查看一下，现在暂存区是干净的，工作区有修改.</p><p>再 git checkout – readme.txt  工作区修改也还原了</p><h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h1 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h1><p>假如我已经提交的文件，我本地给删除了。如何git库中也进行删除呢？</p><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add test.txt"</span></span><br><span class="line">[<span class="keyword">master</span> b84166e] <span class="keyword">add</span> test.txt</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line"></span><br><span class="line">deleted:    test.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br><span class="line"><span class="keyword">rm</span> '<span class="keyword">test</span>.txt'</span><br><span class="line"></span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">"remove test.txt"</span></span><br><span class="line">[master d46f35e] remove <span class="keyword">test</span>.txt</span><br><span class="line"> 1 <span class="keyword">file</span> changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="comment">-- test.txt</span></span><br></pre></td></tr></table></figure><ul><li>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</li></ul><blockquote><p>从来没有被添加到版本库就被删除的文件，是无法恢复的！</p></blockquote><h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时光穿梭&quot;&gt;&lt;a href=&quot;#时光穿梭&quot; class=&quot;headerlink&quot; title=&quot;时光穿梭&quot;&gt;&lt;/a&gt;时光穿梭&lt;/h1&gt;&lt;p&gt;上次内容我们已经生成了一个git仓库，并且创建了一个readme.txt文件。&lt;br&gt;通过 下面命令添加到git仓库&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="git" scheme="//jonnynan.github.io/tags/git/"/>
    
      <category term="版本管理" scheme="//jonnynan.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>git系列之安装并创建版本库</title>
    <link href="//jonnynan.github.io/2019/08/12/git%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%89%E8%A3%85%E5%B9%B6%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/"/>
    <id>//jonnynan.github.io/2019/08/12/git系列之安装并创建版本库/</id>
    <published>2019-08-12T07:22:43.000Z</published>
    <updated>2021-06-24T08:19:40.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git的安装"><a href="#git的安装" class="headerlink" title="git的安装"></a>git的安装</h2><ul><li>windows安装无脑下一步即可</li></ul><ul><li><p>linux：</p><p>  ubuntu :</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure><p>  arch: </p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo pacman -S git</span><br></pre></td></tr></table></figure></li><li><p>macos: </p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>git</span><br></pre></td></tr></table></figure></li></ul><ul><li>linux和macos 也可以源码编译安装。</li></ul><h2 id="git安装后的配置"><a href="#git安装后的配置" class="headerlink" title="git安装后的配置"></a>git安装后的配置</h2><ul><li><p>Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></li></ul><p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址</p><h2 id="git创建版本库"><a href="#git创建版本库" class="headerlink" title="git创建版本库"></a>git创建版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>找一个空目录执行下面命令：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git init</span><br></pre></td></tr></table></figure><p>Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，修改或删除此文件夹内容会造成git仓库被破坏。</p><p>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p><h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>比如，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的.</p><p>现在新建一个文件：readme.txt,内容如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software.</span><br></pre></td></tr></table></figure><p>此文件一定要放在git仓库的目录下，子目录下也可。否则git再厉害也找不到此文件。</p><p>将一个文件放到git仓库只需2步：</p><ul><li><p>第一步，用命令git add告诉Git，把文件添加到仓库：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> readme.txt</span></span><br></pre></td></tr></table></figure></li><li><p>第二步，用命令git commit告诉Git，把文件提交到仓库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"wrote a readme file"</span></span><br><span class="line">[<span class="keyword">master</span> (root-<span class="keyword">commit</span>) eaadf4e] wrote a readme <span class="keyword">file</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">2</span> insertions(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> readme.txt</span><br></pre></td></tr></table></figure></li></ul><p>简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入-m “xxx”行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。</p><p>git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><h3 id="为什么git添加文件要两步走？"><a href="#为什么git添加文件要两步走？" class="headerlink" title="为什么git添加文件要两步走？"></a>为什么git添加文件要两步走？</h3><p>因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2<span class="selector-class">.txt</span> file3.txt</span><br><span class="line">$ git commit -m <span class="string">"add 3 files."</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>初始化一个Git仓库，使用git init命令。</p><p>添加文件到Git仓库，分两步：</p><p>使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；<br>使用命令git commit -m &lt;message&gt;，完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git的安装&quot;&gt;&lt;a href=&quot;#git的安装&quot; class=&quot;headerlink&quot; title=&quot;git的安装&quot;&gt;&lt;/a&gt;git的安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;windows安装无脑下一步即可&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;linux：&lt;/
      
    
    </summary>
    
    
      <category term="git" scheme="//jonnynan.github.io/tags/git/"/>
    
      <category term="版本管理" scheme="//jonnynan.github.io/tags/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
